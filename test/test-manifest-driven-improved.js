/**
 * Test: Improved Manifest-Driven Block Discovery
 * 
 * This enhanced version properly discovers OrbitDB log entries by:
 * 1. Opening the database after downloading manifest + access controller
 * 2. Discovering log entry CIDs from the database log structure
 * 3. Downloading those blocks and storing them
 * 4. Reopening the database with all blocks available
 */

import 'dotenv/config'
import { createLibp2p } from 'libp2p'
import { identify } from '@libp2p/identify'
import { noise } from '@chainsafe/libp2p-noise'
import { yamux } from '@chainsafe/libp2p-yamux'
import { tcp } from '@libp2p/tcp'
import { gossipsub } from '@chainsafe/libp2p-gossipsub'
import { createHelia } from 'helia'
import { createOrbitDB } from '@orbitdb/core'
import { LevelBlockstore } from 'blockstore-level'
import { LevelDatastore } from 'datastore-level'
import { CID } from 'multiformats/cid'
import * as Block from 'multiformats/block'
import * as dagCbor from '@ipld/dag-cbor'
import { sha256 } from 'multiformats/hashes/sha2'
import { backupDatabase } from '../lib/orbitdb-storacha-bridge.js'

/**
 * Create a basic Helia/OrbitDB instance
 */
async function createHeliaOrbitDB(suffix = '') {
  const libp2p = await createLibp2p({
    addresses: {
      listen: ['/ip4/0.0.0.0/tcp/0']
    },
    transports: [tcp()],
    connectionEncryption: [noise()],
    streamMuxers: [yamux()],
    services: {\n      identify: identify(),\n      pubsub: gossipsub({ allowPublishToZeroTopicPeers: true })\n    }\n  })\n  \n  const uniqueId = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n  const blockstore = new LevelBlockstore(`./improved-manifest-test-${uniqueId}${suffix}`)\n  const datastore = new LevelDatastore(`./improved-manifest-test-${uniqueId}${suffix}-data`)\n  \n  await blockstore.open()\n  await datastore.open()\n  \n  const helia = await createHelia({ libp2p, blockstore, datastore })\n  const orbitdb = await createOrbitDB({ ipfs: helia })\n  \n  return { helia, orbitdb, libp2p, blockstore, datastore }\n}\n\n/**\n * Download a block from Storacha using its CID mapping\n */\nasync function downloadBlockFromStoracha(orbitdbCID, cidMappings) {\n  const gateways = [\n    'https://w3s.link/ipfs',\n    'https://gateway.web3.storage/ipfs',\n    'https://ipfs.io/ipfs'\n  ]\n  \n  // Use stored Storacha CID mapping if available\n  let targetCID = cidMappings[orbitdbCID]\n  if (!targetCID) {\n    try {\n      const parsed = CID.parse(orbitdbCID)\n      targetCID = parsed.toV1().toString()\n    } catch (error) {\n      console.warn(`   ‚ö†Ô∏è Could not convert CID ${orbitdbCID}: ${error.message}`)\n      return null\n    }\n  }\n  \n  for (const gateway of gateways) {\n    try {\n      console.log(`   üåê Downloading ${orbitdbCID}...`)\n      \n      const response = await fetch(`${gateway}/${targetCID}`, {\n        timeout: 15000\n      })\n      \n      if (response.ok) {\n        const bytes = new Uint8Array(await response.arrayBuffer())\n        console.log(`   ‚úÖ Downloaded ${bytes.length} bytes`)\n        return bytes\n      }\n    } catch (error) {\n      console.log(`   ‚ö†Ô∏è Failed from ${gateway}: ${error.message}`)\n    }\n  }\n  \n  console.log(`   ‚ùå Could not download block ${orbitdbCID}`)\n  return null\n}\n\n/**\n * Discover log entry blocks by opening the database and inspecting its log\n */\nasync function discoverLogEntries(database, cidMappings) {\n  console.log('üîç Discovering log entry blocks from database...')\n  \n  const discoveredBlocks = new Map()\n  \n  try {\n    // Get all log entries\n    const entries = await database.log.values()\n    console.log(`   üìã Found ${entries.length} log entries in database`)\n    \n    for (const entry of entries) {\n      console.log(`   üîç Processing entry: ${entry.hash}`)\n      \n      // Download the entry block\n      const bytes = await downloadBlockFromStoracha(entry.hash, cidMappings)\n      if (bytes) {\n        const cid = CID.parse(entry.hash)\n        discoveredBlocks.set(entry.hash, { cid, bytes })\n        console.log(`   ‚úÖ Added entry block: ${entry.hash}`)\n        \n        // Also get the identity block if referenced\n        if (entry.identity && !discoveredBlocks.has(entry.identity)) {\n          console.log(`   üîç Processing identity: ${entry.identity}`)\n          const identityBytes = await downloadBlockFromStoracha(entry.identity, cidMappings)\n          if (identityBytes) {\n            const identityCid = CID.parse(entry.identity)\n            discoveredBlocks.set(entry.identity, { cid: identityCid, bytes: identityBytes })\n            console.log(`   ‚úÖ Added identity block: ${entry.identity}`)\n          }\n        }\n      }\n    }\n    \n  } catch (error) {\n    console.warn(`   ‚ö†Ô∏è Error discovering log entries: ${error.message}`)\n  }\n  \n  console.log(`   üìä Discovered ${discoveredBlocks.size} log-related blocks`)\n  return discoveredBlocks\n}\n\n/**\n * Test the improved manifest-driven approach\n */\nasync function testImprovedManifestDrivenApproach() {\n  console.log('üß™ Testing Improved Manifest-Driven Block Discovery')\n  console.log('=' .repeat(60))\n  \n  let sourceNode = null\n  let targetNode = null\n  \n  try {\n    // 1. Create source OrbitDB and populate with data\n    console.log('\\nüìù Step 1: Creating source database...')\n    sourceNode = await createHeliaOrbitDB('-source')\n    \n    const sourceDB = await sourceNode.orbitdb.open('improved-manifest-test', { \n      type: 'documents',\n      create: true \n    })\n    \n    console.log(`   Database created: ${sourceDB.address}`)\n    \n    // Add test data\n    const testDocs = [\n      { _id: 'doc1', title: 'Improved Discovery Test 1', content: 'Testing log discovery' },\n      { _id: 'doc2', title: 'Improved Discovery Test 2', content: 'Finding all log entries' },\n      { _id: 'doc3', title: 'Improved Discovery Test 3', content: 'Complete block reconstruction' }\n    ]\n    \n    for (const doc of testDocs) {\n      await sourceDB.put(doc)\n      console.log(`   ‚úì Added document: ${doc._id}`)\n    }\n    \n    console.log(`   üìä Source database has ${(await sourceDB.all()).length} documents`)\n    \n    // 2. Backup to Storacha \n    console.log('\\nüì§ Step 2: Backing up to Storacha...')\n    const backupResult = await backupDatabase(sourceNode.orbitdb, sourceDB.address)\n    \n    if (!backupResult.success) {\n      throw new Error(`Backup failed: ${backupResult.error}`)\n    }\n    \n    console.log(`   ‚úÖ Backup successful!`)\n    console.log(`   üìç Manifest CID: ${backupResult.manifestCID}`)\n    console.log(`   üìä Blocks uploaded: ${backupResult.blocksUploaded}`)\n    \n    // 3. Close source\n    console.log('\\nüîí Step 3: Closing source database...')\n    await sourceDB.close()\n    await sourceNode.orbitdb.stop()\n    await sourceNode.helia.stop()\n    await sourceNode.blockstore.close()\n    await sourceNode.datastore.close()\n    sourceNode = null\n    \n    await new Promise(resolve => setTimeout(resolve, 2000))\n    \n    // 4. Create fresh target node\n    console.log('\\nüéØ Step 4: Creating fresh target node...')\n    targetNode = await createHeliaOrbitDB('-target')\n    console.log(`   ‚úì Target node ready`)\n    \n    // 5. Download manifest and access controller blocks\n    console.log('\\nüîç Step 5: Downloading core structural blocks...')\n    const coreBlocks = new Map()\n    \n    // Download manifest\n    const manifestBytes = await downloadBlockFromStoracha(\n      backupResult.manifestCID, \n      backupResult.cidMappings\n    )\n    if (!manifestBytes) {\n      throw new Error('Could not download manifest block')\n    }\n    \n    const manifestCid = CID.parse(backupResult.manifestCID)\n    coreBlocks.set(backupResult.manifestCID, { cid: manifestCid, bytes: manifestBytes })\n    \n    // Decode manifest to get access controller CID\n    const manifestBlock = await Block.decode({\n      cid: manifestCid,\n      bytes: manifestBytes,\n      codec: dagCbor,\n      hasher: sha256\n    })\n    \n    const accessControllerCID = manifestBlock.value.accessController.replace('/ipfs/', '')\n    console.log(`   üîç Found access controller: ${accessControllerCID}`)\n    \n    const accessBytes = await downloadBlockFromStoracha(\n      accessControllerCID,\n      backupResult.cidMappings\n    )\n    if (!accessBytes) {\n      throw new Error('Could not download access controller block')\n    }\n    \n    const accessCid = CID.parse(accessControllerCID)\n    coreBlocks.set(accessControllerCID, { cid: accessCid, bytes: accessBytes })\n    \n    console.log(`   üìä Downloaded ${coreBlocks.size} core blocks`)\n    \n    // 6. Store core blocks and partially open database\n    console.log('\\nüì• Step 6: Storing core blocks and opening database...')\n    for (const [cidStr, { cid, bytes }] of coreBlocks) {\n      await targetNode.helia.blockstore.put(cid, bytes)\n      console.log(`   ‚úÖ Stored: ${cidStr}`)\n    }\n    \n    // Open database (this should work with manifest + access controller)\n    const partialDB = await targetNode.orbitdb.open(backupResult.databaseAddress)\n    console.log(`   ‚úÖ Partially opened database: ${partialDB.address}`)\n    \n    // 7. Discover and download log entry blocks\n    console.log('\\nüîç Step 7: Discovering log entry blocks...')\n    const logBlocks = await discoverLogEntries(partialDB, backupResult.cidMappings)\n    \n    if (logBlocks.size === 0) {\n      throw new Error('No log entry blocks were discovered')\n    }\n    \n    // 8. Store all log blocks\n    console.log('\\nüì• Step 8: Storing log entry blocks...')\n    for (const [cidStr, { cid, bytes }] of logBlocks) {\n      await targetNode.helia.blockstore.put(cid, bytes)\n      console.log(`   ‚úÖ Stored log block: ${cidStr}`)\n    }\n    \n    console.log(`   üìä Stored ${logBlocks.size} log blocks`)\n    \n    // 9. Close and reopen database to load all entries\n    console.log('\\nüîÑ Step 9: Reopening database with all blocks...')\n    await partialDB.close()\n    \n    const fullyRestoredDB = await targetNode.orbitdb.open(backupResult.databaseAddress)\n    \n    // Wait for entries to load\n    await new Promise(resolve => setTimeout(resolve, 2000))\n    \n    const allEntries = await fullyRestoredDB.all()\n    \n    console.log(`   ‚úÖ Fully restored database with ${allEntries.length} entries`)\n    \n    // 10. Verify data\n    console.log('\\n‚úÖ Step 10: Verifying restored data...')\n    console.log(`   üìä Expected entries: ${testDocs.length}`)\n    console.log(`   üìä Restored entries: ${allEntries.length}`)\n    \n    for (const entry of allEntries) {\n      console.log(`   ‚úì ${entry._id}: \"${entry.title}\"`)\n    }\n    \n    // 11. Results\n    const totalBlocks = coreBlocks.size + logBlocks.size\n    const success = allEntries.length === testDocs.length && \n                   fullyRestoredDB.address === backupResult.databaseAddress\n    \n    console.log('\\n' + '='.repeat(60))\n    console.log('üéâ IMPROVED MANIFEST-DRIVEN RESULTS')\n    console.log('='.repeat(60))\n    console.log(`‚úÖ Core blocks downloaded: ${coreBlocks.size}`)\n    console.log(`‚úÖ Log blocks discovered: ${logBlocks.size}`)\n    console.log(`‚úÖ Total blocks restored: ${totalBlocks}`)\n    console.log(`‚úÖ Database restoration: ${allEntries.length > 0 ? 'SUCCESS' : 'FAILED'}`)\n    console.log(`‚úÖ Address preservation: ${fullyRestoredDB.address === backupResult.databaseAddress ? 'SUCCESS' : 'FAILED'}`)\n    console.log(`‚úÖ Data integrity: ${allEntries.length === testDocs.length ? 'SUCCESS' : 'PARTIAL'}`)\n    \n    if (success) {\n      console.log('\\nüöÄ CONCLUSION: Improved manifest-driven approach WORKS!')\n      console.log('   ‚úì Only manifest CID needed to start restoration')\n      console.log('   ‚úì All blocks discovered automatically via database structure')\n      console.log('   ‚úì Perfect hash preservation and data integrity')\n      console.log('   ‚úì No need to store complex CID mappings!')\n    } else {\n      console.log('\\n‚ö° CONCLUSION: Needs further refinement')\n      console.log('   ‚ö†Ô∏è Some blocks or entries may still be missing')\n    }\n    \n    return {\n      success,\n      coreBlocks: coreBlocks.size,\n      logBlocks: logBlocks.size,\n      totalBlocks,\n      entriesRestored: allEntries.length,\n      expectedEntries: testDocs.length,\n      addressPreserved: fullyRestoredDB.address === backupResult.databaseAddress\n    }\n    \n  } catch (error) {\n    console.error('\\n‚ùå Test failed:', error.message)\n    console.error('Stack:', error.stack)\n    return {\n      success: false,\n      error: error.message\n    }\n  } finally {\n    // Cleanup\n    console.log('\\nüßπ Cleaning up...')\n    \n    if (sourceNode) {\n      try {\n        await sourceNode.orbitdb.stop()\n        await sourceNode.helia.stop() \n        await sourceNode.blockstore.close()\n        await sourceNode.datastore.close()\n      } catch (error) {\n        console.warn('Source cleanup warning:', error.message)\n      }\n    }\n    \n    if (targetNode) {\n      try {\n        await targetNode.orbitdb.stop()\n        await targetNode.helia.stop()\n        await targetNode.blockstore.close() \n        await targetNode.datastore.close()\n      } catch (error) {\n        console.warn('Target cleanup warning:', error.message)\n      }\n    }\n    \n    console.log('   ‚úì Cleanup completed')\n  }\n}\n\n// Run the test\nif (import.meta.url === `file://${process.argv[1]}`) {\n  testImprovedManifestDrivenApproach()\n    .then(result => {\n      console.log('\\nüìã Final Result:', result)\n      process.exit(result.success ? 0 : 1)\n    })\n    .catch(error => {\n      console.error('\\nüí• Test execution failed:', error)\n      process.exit(1)\n    })\n}\n\nexport { testImprovedManifestDrivenApproach }
